// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

// To use centroid sampling we need to have version 300 es shaders, which requires changing:
// attribute to in
// varying to out when in vertex shaders or in when in fragment shaders
// defining an out vec4 FragColor and replacing uses of gl_FragColor with FragColor
// texture2D to texture
#if __VERSION__ >= 300

	// version 300 code

	#ifdef MSAA_FRAMEBUFFER_ENABLED
		#define _centroid centroid
	#else
		#define _centroid
	#endif

	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif

	#define varying in
	#define texture2D texture
	out vec4 FragColor;
	#define gl_FragColor FragColor
#else

	// version 100 code

	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

#define WEATHER
#define ADV_WATER
#define REFLECTION
#define SUN_REFLECTION
#define ADV_LAVA

varying vec4 color;
varying float new_fog;
varying vec3 screen_pos;

varying highp vec3 fragment_pos;
varying highp vec3 look_vector;

varying float water_plane_flag;
varying float lava_plane_flag;

varying POS3 posE;

#ifdef FOG
varying vec4 fogColor;
#endif

#ifdef NEAR_WATER
varying float cameraDist;
#endif

#include "shaders/util.h"

uniform sampler2D TEXTURE_0;
uniform sampler2D TEXTURE_1;
uniform sampler2D TEXTURE_2;
uniform vec2 FOG_CONTROL;
uniform vec4 FOG_COLOR;
uniform highp float TIME;

const vec3 lightDir = vec3(-1.0, -0.0, -1.0);

highp float cos_between_vecs(highp vec3 v1, highp vec3 v2){
 return (v1.x * v2.x + v1.y * v2.y + v1.z * v2.z) / length(v1) / length(v2);
}

highp float CalcLightByNormal(highp vec3 lightdir, highp vec3 normal){
 return min(1.0, acos(cos_between_vecs(lightdir, normal)) / 3.14195);
}

highp float randff(highp float n){
 return fract(cos(n) * 3782.288);
}

highp float smoothrand(highp float pos){
 highp float start = floor(pos);
 highp float smoothy = smoothstep(0.0, 1.0, fract(pos));
 return mix(randff(start), randff(start + 1.0), smoothy);}

highp float smoothrand2d(highp float horizont, highp float forward){
 highp float start = floor(forward);
 highp float smoothy = smoothstep(0.0, 1.0, fract(forward));
 return mix(smoothrand(horizont + randff(start) * 1000.0), smoothrand(horizont + randff(start + 1.0) * 1000.0), smoothy);
}

highp float CheapWaterMap(highp vec3 pos){
pos.z += TIME * 0.5;
 highp float wave1 = smoothrand2d(pos.z+pos.z+pos.z, pos.x+pos.x+pos.x);
 highp float wave2 = sin(wave1) * 0.5 + 0.5;
float interp = sin(TIME * 5.0 + pos.x+pos.z+pos.x+pos.z) * sin(pos.z) * 1.0;
 return mix(wave1, wave2, interp);
}

highp vec3 WaterNormalMap(highp vec3 pos){
 highp float value = (CheapWaterMap(pos + vec3(0.0, 0.0, 0.1)) - CheapWaterMap(pos)) * 1.0;
 return vec3(0.0, 1.0, -value);
}

vec3 getWaterColor(float light){
 vec3 base_color = vec3(0.0, 0.0, 1.0);
 if(light < 0.5){return base_color * sqrt(2.0 * light);}
 return base_color + (1.0 - base_color) * pow((light - 0.5) / 0.5, 2.0);
}

const vec3 origin_water_normal = vec3(0.0, 1.0, 0.0);

#ifdef REFLECTION
highp float CloudMap1(highp vec3 dir, float sizescale, float timescale){

 highp float timer = TIME * timescale;
 dir *= sizescale;
 dir.z += timer;
 highp float horizont = dir.x;
 highp float forward = dir.x + smoothrand2d((dir.x + dir.z) / 7.0, timer / 3.2) * 2.0;
 highp float rand1 = smoothrand2d(horizont / 2.0 + 2526.278, forward);

 return pow(rand1 * 1.1, 4.0);
}

highp float CloudMap2(highp vec3 dir, float sizescale, float timescale){

 highp float timer = TIME * timescale;
 dir *= sizescale;
 dir.z += timer;
 highp float horizont = dir.x;
 highp float forward = dir.x;
 highp float rand1 = smoothrand2d(horizont, forward);
 highp float rand2 = smoothrand2d(horizont * 3.0 * 472.789, forward * 4.0);
 highp float rand3 = smoothrand2d(horizont * 4.0 + 637.29, forward * 4.0);
 
 return rand1 + (rand2 * 0.5 + rand3 * 0.75) * rand1;
}

highp float TypeMap(highp vec3 dir, float timescale){
 return CloudMap1(dir, 0.1, 0.05 * timescale);}

vec4 Colorize(float cloud, float cloudmap, float darken, vec3 cloudcolor){
 float light = color.b;
 vec3 border = vec3(1.0);
 vec4 result = vec4(cloud);
 result.rgb = (cloudcolor - darken * 0.5 - cloudmap * darken * 0.2) * cloud * (light * 0.5 + 0.5) + border * (1.0 - cloud);
 return result;
}

vec4 FullCloudMap(highp vec3 dir, float timescale){
 highp float gamma = TypeMap(dir, timescale) ;
 highp float darken = clamp((gamma - 0.0) * 1.6, 0.0, 1.0);
 highp float cloud2 = gamma;
 highp float cloud1 = 1.0 - cloud2;
 highp float cloudmap = CloudMap2(dir, 0.1, 0.5 * timescale);
 highp float rescloud = clamp(cloudmap + cloud2 * 2.0 - 1.0, 0.0, 1.0);
 vec4 colorized = Colorize(rescloud, cloudmap, 0.0, vec3(1.0));
 return colorized;
}

highp vec3 PositionTransform(highp vec3 pos, highp float height){
 highp float dis = length(pos.xz);
 highp float ang = atan(dis, height);
 return pos * cos(ang);
}

vec4 getSunColor(highp vec3 pos, float day_flag){
 highp vec3 sun_pos = vec3(0.0, 100.0, -600.0);
 float white = clamp(abs(day_flag - 0.7) / 0.3 + 0.2, 0.0, 1.0);
 vec4 sun_color = vec4(1.0, white, white, 1.0);
 sun_color.a = pow(max(0.0, 1.0 - length(sun_pos.xz - pos.xz) / 160.0), 0.6);
 return sun_color;
}
#endif

bool DetectedNether(vec4 likefogcontrol){
if(likefogcontrol.r > likefogcontrol.b && likefogcontrol.r < 0.5 && likefogcontrol.b < 0.2){
return true;
} else {
return false;}
}

vec3 day_light = vec3(1.7,1.8,1.9);
vec3 moon_Color = vec3(0.025, 0.06, 0.08)*0.15;
vec3 sun_Sunset = vec3(0.6,0.3,0.0);

#ifndef BYPASS_PIXEL_SHADER
vec4 moonLight(vec4 light, float null){

float amount = 1.0;
float colorDesat = dot(light.rgb, vec3(9.9));
float test = 1.0;

light.rgb = mix(light.rgb, vec3(colorDesat) * moon_Color, amount * null);

return light;}

vec4 dayLight(vec4 light, float null){

vec4 lum_day = light * vec4(vec3(day_light), 1.0);
vec4 final_day = lum_day;

return final_day;}

vec4 sunLight(vec4 light, float null){

float sunset = (light.r + light.g + light.b) / 1.5;

return mix( light, vec4 (sunset * sun_Sunset.r, sunset * sun_Sunset.g, sunset * sun_Sunset.b, light.a), null);}

vec4 lightMap(vec4 light, vec2 curr, float setLight){

float notlight = (1.0 - uv1.x);
float day = uv1.y * 0.75 * setLight;
float sun = (0.5-abs(0.5-setLight))*notlight*uv1.y;
float night = uv1.y * notlight *0.95*(1.0-setLight);

return sunLight(dayLight(moonLight(light,night),day),sun);}

vec3 calc_Torchlight(vec3 color){

float lum = (color.r + color.g + color.b) - uv1.y;

vec3 torch_Color = (color.rgb) * lum;

return torch_Color.rgb * pow(uv1.x * 0.7,1.0);}
#endif

void main()
{
#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(0, 0, 0, 0);
	return;
#else 

float vignette = max(0.0,length(screen_pos.xy));

vignette = 1.0 - max(0.0,vignette-0.5);

#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
vec4 diffuse = texture2D( TEXTURE_0, uv0 );
vec4 tex = texture2D( TEXTURE_0, uv0 );
vec4 uvs = texture2D( TEXTURE_1, vec2(uv1.x*0.65,uv1.y));
#else
vec4 diffuse = texture2D_AA(TEXTURE_0, uv0);
#endif

vec4 inColor = color;
vec4 fog = FOG_COLOR;
vec3 shd_day = vec3(0.81,0.83,0.85);
vec3 shd_sun = vec3(0.5,0.9,1.0);
vec3 shd_night = vec3(1.1);
vec3 torch = vec3(0.0,0.0,0.0);
float fog_flag = 0.0;
float lea_flag = 0.0;
float mobshd = (posE.y+1.5)*0.9;
float no_lea_flag = 0.0;
vec3 torch_b = vec3(0.6,0.4,0.0);
vec2 tex_pos =		floor(vec2(uv0.x * 32.0, uv0.y * 16.0));
vec4 transf = texture2D( TEXTURE_1,vec2(0.0, 1.0));
float setLight = (transf.r - 0.5) / 0.5;
setLight = max (0.0, min(1.0, setLight));
	
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
	inColor.b = 1.0;
#endif

#ifdef ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
		float alphaThreshold = .05;
	#else
		float alphaThreshold = .5;
	#endif
	if(diffuse.a < alphaThreshold)
		discard;
#endif

	diffuse = diffuse * uvs;

#ifndef SEASONS

#if !defined(ALPHA_TEST) && !defined(BLEND)
	diffuse.a = inColor.a;
#elif defined(BLEND)
	diffuse.a *= inColor.a;
	#ifdef NEAR_WATER
		float alphaFadeOut = clamp(cameraDist, 0.0, 1.0);
		diffuse.a = mix(diffuse.a, 1.0, alphaFadeOut);
	#endif
#endif	
	
	diffuse.rgb *= inColor.rgb;
#else
	vec2 uv = inColor.xy;
	diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	diffuse.rgb *= inColor.aaa;
	diffuse.a = 1.0;
#endif

#ifdef WEATHER
if(FOG_CONTROL.x < 0.55 && FOG_CONTROL.x > 0.1){
fog_flag = 1.0;
sun_Sunset.rgb *= diffuse.rgb;
if(fog.r > 0.15 && fog.g > 0.15){
if(FOG_CONTROL.x < 0.55 && FOG_CONTROL.x > 0.1){
diffuse.rgb *= vec3(0.5);
diffuse.rgb = mix(diffuse.rgb,fog.rgb/day_light,new_fog*4.0);
}}}
#endif

#if defined(NEAR_WATER) || defined(REFLECT_FAR_WATER)
#ifndef NEAR_WATER
if(water_plane_flag > 0.5){
#endif
#ifdef ADV_WATER
highp vec3 frag_water_normal = WaterNormalMap(fragment_pos);

highp vec3 water_normal = mix(frag_water_normal, origin_water_normal, min(1.0, length(look_vector.xz) / max(50.0, abs(look_vector.y) * 4.0)));

highp float view_angle = acos(abs(cos_between_vecs(look_vector, water_normal)));

diffuse = vec4(0.2,0.5,0.6,0.0) * uvs;
if(uv1.y >= 0.5){
if (FOG_CONTROL.x < 0.55 && FOG_CONTROL.x > 0.1){
diffuse = vec4(0.5) * uvs;
}}

#ifdef REFLECTION
highp vec3 reflected_dir = normalize(reflect(look_vector, water_normal));

highp vec3 reflected_pos = reflected_dir * 100.0 / reflected_dir.y + look_vector;

vec4 cloud = FullCloudMap(PositionTransform(reflected_pos * 2.3, 500.0), 0.3);

diffuse = mix(diffuse, cloud, (cloud.a * uv1.y));

diffuse.a = pow(view_angle / (3.0), 1.4);

vec4 suncolor = getSunColor(reflected_pos * 2.3, uvs.r);
diffuse += suncolor * suncolor.a;
#endif
#endif
#endif

shd_day.rgb = mix(shd_day.rgb,fog.rgb *vec3(1.9,1.4,1.9)*0.5,new_fog);

torch.rgb += calc_Torchlight(torch_b.rgb);

#if defined(FOG) || defined(NETHER)
if(DetectedNether(FOG_COLOR)){
if(no_lea_flag == 0.0){
if(uv1.y <= 0.8751){
day_light.rgb *= shd_day + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
diffuse.rgb *= 0.5 + torch * uv1.x;
}}}
#endif

#ifdef FOG
if(color.a == 0.0){
lea_flag = 1.0;
if(uv1.y<=0.8749&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}
#endif
#ifdef LOW_PRECISION
if(color.a == 0.0){
lea_flag = 1.0;
diffuse.rgb *= 1.4;
if(uv1.y<=0.8749&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}
#endif

if(lea_flag <= 0.8749){
if(((uv1.y <= 0.8751)||(color.w<=0.619))&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(((uv1.y<=0.8760)||(color.w<=0.625))&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(((uv1.y<=0.8770)||(color.w<=0.630))&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(((uv1.y<=0.8780)||(color.w<=0.635))&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(((uv1.y<=0.8790)||(color.w<=0.64))&&fog_flag==0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
day_light.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}

if(uv1.y>=0.8751&&fog_flag==0.0){if(color.w>=0.619){
if(posE.x < 0.25 && posE.x > -0.25 && posE.z < mobshd-0.0 && posE.z > mobshd-0.85&&posE.z < -0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.5 && posE.x > -0.5 && posE.z < mobshd-0.85 && posE.z > mobshd-1.55&&posE.z < -0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.25 && posE.x > -0.25 && posE.z < mobshd-1.55 && posE.z > mobshd-2.01&&posE.z < -0.0){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}}
if(uv1.y>=0.8760&&fog_flag==0.0){if(color.w>=0.625){
if(posE.x < 0.26 && posE.x > -0.26 && posE.z < mobshd-0.01 && posE.z > mobshd-0.86&&posE.z < -0.01){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.51 && posE.x > -0.51 && posE.z < mobshd-0.86 && posE.z > mobshd-1.56&&posE.z < -0.01){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.26 && posE.x > -0.26 && posE.z < mobshd-1.56 && posE.z > mobshd-2.02&&posE.z < -0.01){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}}
if(uv1.y>=0.8770&&fog_flag==0.0){if(color.w>=0.630){
if(posE.x < 0.27 && posE.x > -0.27 && posE.z < mobshd-0.02 && posE.z > mobshd-0.87&&posE.z < -0.02){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.52 && posE.x > -0.52 && posE.z < mobshd-0.87 && posE.z > mobshd-1.57&&posE.z < -0.02){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.27 && posE.x > -0.27 && posE.z < mobshd-1.57 && posE.z > mobshd-2.03&&posE.z < -0.02){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}}
if(uv1.y>=0.8780&&fog_flag==0.0){if(color.w>=0.635){
if(posE.x < 0.28 && posE.x > -0.28 && posE.z < mobshd-0.03 && posE.z > mobshd-0.88&&posE.z < -0.03){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.53 && posE.x > -0.53 && posE.z < mobshd-0.88 && posE.z > mobshd-1.58&&posE.z < -0.03){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.28 && posE.x > -0.28 && posE.z < mobshd-1.58 && posE.z > mobshd-2.04&&posE.z < -0.03){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}}
if(uv1.y >= 0.8790&&fog_flag==0.0){if(color.w>=0.64){
if(posE.x < 0.29 && posE.x > -0.29 && posE.z < mobshd-0.04 && posE.z > mobshd-0.89&&posE.z < -0.04){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.54 && posE.x > -0.54 && posE.z < mobshd-0.89 && posE.z > mobshd-1.59&&posE.z < -0.04){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}
if(posE.x < 0.29 && posE.x > -0.29 && posE.z < mobshd-1.59 && posE.z > mobshd-2.05&&posE.z < -0.04){
sun_Sunset.rgb *= shd_sun + torch * uv1.x;
diffuse.rgb *= shd_day + torch * uv1.x;
moon_Color.rgb *= shd_night + torch * uv1.x;
}}}

diffuse.rgb = mix(diffuse.rgb,fog.rgb/day_light,new_fog);

diffuse.rgb *= vignette;

gl_FragColor = lightMap(diffuse, uv1, setLight);

#ifdef FOG
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor.rgb, fogColor.a );
#endif

#endif // BYPASS_PIXEL_SHADER
}
